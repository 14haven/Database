2020년 12월 1일

데이터 모델링이란?
데이터의 구조를 실체(Entity)와 관계(Relation)을 중심으로 명확하고 체계적으로 표현하여
문서화 하는 기법


논리적 모델링
불필요한 데이터의 중복의 방지함을 통해 데이터 품질의 보장이 목적이다.

논리적 모델링 단계
개념적 모델링(ERD) -> 정규화 -> 테이블 상세화

정규화 (DB normalization)
데이터 모델링 목적
데이터가 증가함에 따라 데이터 중복 증가와 SQL 응답 속도 저하의 문제가 발생한다.
이 문제점을 해결하기 위해서 모델링을 한다.

정규화란?
관계형 데이터베이스에서 데이터를 구조화 하는 작업(중복을 찾아 제거해 나가는 과정)
구조들을 조금 더 효율적으로 사용 할 수 있도록, 문제가 발생하지 않도록 하는 것
일반성을 확보하고 중복을 제거하는 것

정규화의 목적
- 데이터의 중복을 방지하고 보다 효율적으로 데이터를 저장하기 위함
- 삽입, 삭제, 갱신 이상의 발생 가능성을 줄이기 위함 (변경 할 때 문제가 발생하는 것을 막기 위함)

이상(Anomaly)
- 삽입 이상
불필요한 정보를 함께 저장하지 않고는 어떤 정보를 저장하는 것이 불가능

- 갱신 이상
반복된 데이터 중에 일부만 수정하면 데이터의 불일치가 발생

- 삭제 이상
유용한 정보를 함께 삭제하지 않고는 어떤 정보를 삭제하는 것이 불가능



정규화 과정
제 1 정규화
엔티티에서 하나의 속성이 복수의 값을 갖도록 설계되었을 때
하나의 속성이 단일 값을 갖도록 한느 것

제 2정규화 (주식별자와 종속된 것을 찾는 것)
주식별자가 아닌 속성 중에서 주식별자 전체가 아닌 일부 속성에 종속된 속성을 찾아 제거하는 것
다른 속성들은 모두 주식별자에 종속되어야 한다 => 완전 함수적 종속

종속된다 : 하나의 어떤 속성을 알고 있으면 나머지 속성들은 그것을 따라간다.
예 ) 품목코드 -> 품목 단가, 품목명
품목코드가 바뀌면 품목 단가, 품목 명이 바뀐다.

제 3 정규화 (주식별자가 아닌 것 중에서 종속 된 것을 찾는 것)
주식별자가 아닌 속성들 중에서 종속 관계에 있는 속성을 찾아 제거하는 것

정규화가 필요 없는 설계 기법
처음부터 정규화가 필요없는 모델링을 하는 것이 바람직하다.

원칙1. 장부나 전표에서 머리부와 서술부는 별도의 엔티티로 저장한다.
원칙2. 코드-코드 값의 관계에 있는 속성들은 별도의 엔티티로 구성한다.
(종속되는 것에 대해서 따로따로 미리 만든다.)


--------------------------------------------------------------------------------------------------------

물리적 모델링

* 물리적 모델링 개요

물리적 모델링이란?
논리적 설계의 산출물인 ERD의 요소들을 관계형 데이터베이스의 요소들로 전환하는 것

- 논리적 DB 설계 (데이터 모델링) :
DBMS의 종류나 제품에 상관없이 진행 (ERD는 어떤 데이터베이스를 사용해도 적용가능)
- 물리적 DB 설계 :
특정 DBMS를 전제로 진행 (적용 DBMS의 특성을 고려)

엔티티 이름, 속성 이름, 속성에 대한 데이터타입(크기), 제약조건 등을 생각해야 한다.

사용자 DBMS 결정 - 데이터 타입 크기 결정 및 업무 분석 - 반정규화 - 무결성 제약조건 정의
- 뷰,인덱스 정의 - 데이터베이스 생성

* 논리적 모델링 VS 물리적 모델링
ERD 요소 전환
엔티티(entity) - 테이블(table)
속성(attribute) - 컬럼(column)
주식별자(primary identifier) - 기본키(primary key)
외래식별자(foreign identifier) - 외래키(foreign key)

물리적 DB 설계 - 뷰, 인덱스도 있음


* 반정규화
반정규화(De-Nomalization)란?
- 정규화 작업이 완료된 후 데이터 물리 모델링 과정 중 시스템의 성능 향상,
개발 과정의 편의성, 운영의 단순화를 추구
- 중복은 감수하고 데이터베이스의 성능을 향상시키는 것. (특히 검색 속도)
- 정규화를 통한 데이터 무결성 유지도 중요하지만, 다수 사용자가 동시 이용하는 환경에서
일정 성능을 유지하는 것도 매우 중요.
(정규화를 거꾸로 하는 것, 프로그램적인 관점에서 생각해서 다시 합쳐주거나 다른 방향으로 쪼개는 것,
다시 합치면 중복이 발생 할 수 밖에 없다, 
중복을 감수하지만 변경 이상이 생길 수 있음 -> 하지만 변경 이상은 생겨서는 안된다.
중복은 감수하되 애플리케이션 차원에서 변경이상은 발생하지않게 막아야 한다.)

정규화 -> 엔티티를 쪼갤만큼 다 쪼갰다
쪼개서 어떤 기능을 구현하려다보니까 오히려 안쪼개느니만 못한 것이 있다.
오히려 자른게 더 비효울적
ex) 조인해서 조회하는 기능만 쓸거임, 쓸 때마다 세개를 조인해서 같이 조회 해야 함 
중복 감수하고 그냥 세개 다시 합친다.

* 정규화 사례
- CASE1 - 엔티티의 통합
항상 혹은 대부분 조인에 의한 검색을 하고, 검색이 빈번히 이루어지는 두 개의 엔티티를 대상으로 한다.

- CASE2 - 수직분할에 의한 반정규화
엔티티의 튜플 수 및 속성의 수가 매우 많고,
엔티티의 속성들이 그룹화되어 각 그룹이 특정 부서 혹은 응용 프로그램에 의해서만 사용될 때

- CASE3 - 수평분할에 의한 반정규화
한 테이블 내에서 튜플의 조회 빈도에 따라 엔티티를 분할.

- CASE4 - 속성의 중복에 의한 반정규화
조인하여 가져다 쓰는 속성의 수가 적을 때는 엔티티의 통합은 비효율적이다.
따라서 속성을 중복하여 저장한다.

- CASE5 - 관계에 대한 반정규화
속성의 중복에 의한 반정규화와 비슷하나 차이가 있다면 중복을 하는 속성이 다른 엔티티와의
관계를 맺어주기 위한 외래키로 사용된다는 것이다. (조인해야 할 엔티티를 줄여줌)
